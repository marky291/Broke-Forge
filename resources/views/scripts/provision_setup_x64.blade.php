#!/usr/bin/env bash
set -euo pipefail

# Ensure script is running as root
if [ "$EUID" -ne 0 ]; then
  echo "[!] This script must be run as root user"
  echo "[!] Please run: 'sudo su' first"
  exit 1
fi

CALLBACK_STARTED_URL='{!! $callbackUrls['started'] ?? '' !!}'
CALLBACK_COMPLETED_URL='{!! $callbackUrls['completed'] ?? '' !!}'

notify_callback() {
  local url="$1"
  local callback_type="$2"

  if [ -z "${url}" ]; then
    echo "[!] WARNING: No callback URL provided for ${callback_type}"
    return
  fi

  echo "[→] Sending ${callback_type} callback to BrokeForge..."

  if command -v curl >/dev/null 2>&1; then
    # Use -L to follow redirects and preserve POST method
    if curl -L -X POST "$url" >/dev/null 2>&1; then
      echo "[✓] ${callback_type} callback sent successfully"
    else
      echo "[!] WARNING: ${callback_type} callback failed (curl exit code: $?)"
    fi
  elif command -v wget >/dev/null 2>&1; then
    if wget --method=POST -qO- "$url" >/dev/null 2>&1; then
      echo "[✓] ${callback_type} callback sent successfully"
    else
      echo "[!] WARNING: ${callback_type} callback failed (wget exit code: $?)"
    fi
  else
    echo "[!] WARNING: Neither curl nor wget available - cannot send callback"
  fi
}

notify_callback "$CALLBACK_STARTED_URL" "started"

# Generated by {{ $appName }} for server setup

ROOT_PASSWORD='{{ $rootPassword }}'

echo "[+] Starting provisioning for users: {{ $sshUser }} (root) and {{ $appUser }} (app)"

# Setup SSH for root user ({{ $sshUser }}) with server-specific keys
if [ "{{ $sshUser }}" = "root" ]; then
  # Ensure root SSH directory exists
  if [ ! -d /root/.ssh ]; then
    mkdir -p /root/.ssh
    chmod 700 /root/.ssh
  fi

  # Deploy root private key (for outgoing connections from BrokeForge to this server)
  cat > /root/.ssh/id_rsa <<'ROOT_PRIVATE_KEY_EOF'
{{ $rootPrivateKeyContent }}
ROOT_PRIVATE_KEY_EOF
  chmod 600 /root/.ssh/id_rsa

  # Deploy root public key
  cat > /root/.ssh/id_rsa.pub <<'ROOT_PUBLIC_KEY_EOF'
{{ $rootPublicKeyContent }}
ROOT_PUBLIC_KEY_EOF
  chmod 644 /root/.ssh/id_rsa.pub

  # Add public key to authorized_keys for incoming BrokeForge connections (overwrite to ensure current key is used)
  echo "{{ trim($rootPublicKeyContent) }}" > /root/.ssh/authorized_keys
  chmod 600 /root/.ssh/authorized_keys

  # Ensure strict ownership
  chown root:root /root
  chown -R root:root /root/.ssh

  echo "[+] Root user SSH keys configured (server-specific)"
else
  # Setup SSH for non-root ssh user if different
  if ! id -u "{{ $sshUser }}" >/dev/null 2>&1; then
    useradd -m -s /bin/bash "{{ $sshUser }}" || adduser --disabled-password --gecos "" "{{ $sshUser }}"
  fi

  mkdir -p "/home/{{ $sshUser }}/.ssh"

  # Deploy root private key
  cat > "/home/{{ $sshUser }}/.ssh/id_rsa" <<'ROOT_PRIVATE_KEY_EOF'
{{ $rootPrivateKeyContent }}
ROOT_PRIVATE_KEY_EOF
  chmod 600 "/home/{{ $sshUser }}/.ssh/id_rsa"

  # Deploy root public key
  cat > "/home/{{ $sshUser }}/.ssh/id_rsa.pub" <<'ROOT_PUBLIC_KEY_EOF'
{{ $rootPublicKeyContent }}
ROOT_PUBLIC_KEY_EOF
  chmod 644 "/home/{{ $sshUser }}/.ssh/id_rsa.pub"

  # Add to authorized_keys (overwrite to ensure current key is used)
  echo "{{ trim($rootPublicKeyContent) }}" > "/home/{{ $sshUser }}/.ssh/authorized_keys"

  chown -R "{{ $sshUser }}":"{{ $sshUser }}" "/home/{{ $sshUser }}/.ssh"
  chmod 700 "/home/{{ $sshUser }}/.ssh"
  chmod 600 "/home/{{ $sshUser }}/.ssh/authorized_keys"

  echo "[+] SSH user '{{ $sshUser }}' SSH keys configured (server-specific)"
fi

# Setup SSH for application user ({{ $appUser }}) with server-specific keys
if ! id -u "{{ $appUser }}" >/dev/null 2>&1; then
  useradd -m -s /bin/bash "{{ $appUser }}" || adduser --disabled-password --gecos "" "{{ $appUser }}"
fi

mkdir -p "/home/{{ $appUser }}/.ssh"

# Deploy user private key
cat > "/home/{{ $appUser }}/.ssh/id_rsa" <<'USER_PRIVATE_KEY_EOF'
{{ $userPrivateKeyContent }}
USER_PRIVATE_KEY_EOF
chmod 600 "/home/{{ $appUser }}/.ssh/id_rsa"

# Deploy user public key
cat > "/home/{{ $appUser }}/.ssh/id_rsa.pub" <<'USER_PUBLIC_KEY_EOF'
{{ $userPublicKeyContent }}
USER_PUBLIC_KEY_EOF
chmod 644 "/home/{{ $appUser }}/.ssh/id_rsa.pub"

# Add to authorized_keys (overwrite to ensure current key is used)
echo "{{ trim($userPublicKeyContent) }}" > "/home/{{ $appUser }}/.ssh/authorized_keys"

chown -R "{{ $appUser }}":"{{ $appUser }}" "/home/{{ $appUser }}/.ssh"
chmod 700 "/home/{{ $appUser }}/.ssh"
chmod 600 "/home/{{ $appUser }}/.ssh/authorized_keys"

echo "[+] App user '{{ $appUser }}' SSH keys configured (server-specific)"

# Configure Git for brokeforge user
sudo -u {{ $appUser }} git config --global user.name '{{ $appName }}'
sudo -u {{ $appUser }} git config --global user.email '{{ $appUser }}@{{ str_replace(' ', '', strtolower($appName)) }}.local'

# Set proper permissions on app user's home directory (755 for SSH compatibility)
# SSH requires home directory to NOT be group-writable
chown -R {{ $appUser }}:{{ $appUser }} /home/{{ $appUser }}
chmod 755 /home/{{ $appUser }}

echo "[+] App user '{{ $appUser }}' configured for Git operations with full ownership of home directory"

# Set passwords for all configured users
echo "root:${ROOT_PASSWORD}" | chpasswd

# Set password for SSH user if different from root
if [ "{{ $sshUser }}" != "root" ]; then
  echo "{{ $sshUser }}:${ROOT_PASSWORD}" | chpasswd || true
fi

# Set password for application user
echo "{{ $appUser }}:${ROOT_PASSWORD}" | chpasswd || true

echo "[+] User passwords configured"

# Basic updates and common tools
if command -v apt-get >/dev/null 2>&1; then
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  apt-get install -y curl ca-certificates sudo

  echo "[+] Base packages installed"

  apt-get install -y openssh-server
  systemctl enable --now ssh 2>/dev/null || systemctl enable --now sshd 2>/dev/null || true

  echo "[+] OpenSSH installed"

  mkdir -p /etc/ssh/sshd_config.d
  ssh-keygen -A
  cat > /etc/ssh/sshd_config.d/49-brokeforge.conf <<'EOF'
# Managed by BrokeForge
Port {{ $sshPort ?? 22 }}
PasswordAuthentication no
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PermitRootLogin prohibit-password
EOF

  # Restart SSH and wait for it to be fully ready
  systemctl restart ssh 2>/dev/null || systemctl restart sshd 2>/dev/null || true
  sleep 3

  echo "[+] SSH configuration updated"

  # Generate SSH host keys if they don't exist
  ssh-keygen -A 2>/dev/null || true

  # Get the server's IP address for known_hosts
  SERVER_IP=$(ip route get 1 | awk '{print $7;exit}' 2>/dev/null || hostname -I | awk '{print $1}')

  # Add localhost entries to known_hosts for all users to prevent SSH prompts
  for user_home in /root /home/{{ $sshUser }} /home/{{ $appUser }}; do
    if [ -d "$user_home" ]; then
      mkdir -p "$user_home/.ssh"
      touch "$user_home/.ssh/known_hosts"
      ssh-keyscan -H localhost 2>/dev/null >> "$user_home/.ssh/known_hosts" || true
      ssh-keyscan -H 127.0.0.1 2>/dev/null >> "$user_home/.ssh/known_hosts" || true
      if [ -n "$SERVER_IP" ]; then
        ssh-keyscan -H "$SERVER_IP" 2>/dev/null >> "$user_home/.ssh/known_hosts" || true
      fi
      # Fix permissions
      if [ "$user_home" = "/root" ]; then
        chown root:root "$user_home/.ssh/known_hosts"
      elif [ "$user_home" = "/home/{{ $sshUser }}" ]; then
        chown {{ $sshUser }}:{{ $sshUser }} "$user_home/.ssh/known_hosts"
      elif [ "$user_home" = "/home/{{ $appUser }}" ]; then
        chown {{ $appUser }}:{{ $appUser }} "$user_home/.ssh/known_hosts"
      fi
      chmod 644 "$user_home/.ssh/known_hosts"
    fi
  done

  # Add GitHub to known_hosts for brokeforge user (for Git operations)
  if [ -d /home/{{ $appUser }}/.ssh ]; then
    ssh-keyscan -H github.com 2>/dev/null >> /home/{{ $appUser }}/.ssh/known_hosts || true
    ssh-keyscan -H gitlab.com 2>/dev/null >> /home/{{ $appUser }}/.ssh/known_hosts || true
    ssh-keyscan -H bitbucket.org 2>/dev/null >> /home/{{ $appUser }}/.ssh/known_hosts || true
    chown {{ $appUser }}:{{ $appUser }} /home/{{ $appUser }}/.ssh/known_hosts
    chmod 644 /home/{{ $appUser }}/.ssh/known_hosts
  fi

  echo "[+] SSH known_hosts configured (including Git providers for {{ $appUser }})"

  if command -v ufw >/dev/null 2>&1; then
    ufw allow {{ $sshPort ?? 22 }}/tcp || true
  fi
  if command -v firewall-cmd >/dev/null 2>&1 && systemctl is-active --quiet firewalld; then
    firewall-cmd --permanent --add-port={{ $sshPort ?? 22 }}/tcp || true
    firewall-cmd --reload || true
  fi

  echo "[+] Firewall opened for SSH"
fi

# Wait for SSH to be fully ready before declaring completion
echo "[+] Waiting for SSH to be ready..."
sleep 5

# Verify SSH is actually accepting connections on all configured users
echo "[+] Verifying SSH access for all users..."
VERIFICATION_FAILED=0

# Test root user
if ! sudo -u root ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i /root/.ssh/id_rsa root@localhost 'whoami' >/dev/null 2>&1; then
  echo "[!] WARNING: Root SSH verification failed"
  VERIFICATION_FAILED=1
fi

# Test app user
echo "[→] Testing SSH for user: {{ $appUser }}"
echo "[→] Checking SSH key permissions..."
ls -la /home/{{ $appUser }}/.ssh/ || true
echo "[→] Verifying key fingerprints match..."
echo "Private key fingerprint:"
ssh-keygen -lf /home/{{ $appUser }}/.ssh/id_rsa || true
echo "Public key in authorized_keys:"
ssh-keygen -lf /home/{{ $appUser }}/.ssh/authorized_keys || true
echo "[→] Testing direct SSH connection..."
if sudo -u {{ $appUser }} ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i /home/{{ $appUser }}/.ssh/id_rsa {{ $appUser }}@localhost 'whoami' 2>/tmp/ssh_test_{{ $appUser }}_err.log | grep -q "{{ $appUser }}"; then
  echo "[✓] {{ $appUser }} SSH verified"
else
  echo "[!] WARNING: {{ $appUser }} SSH verification failed"
  echo "[!] Error output:"
  cat /tmp/ssh_test_{{ $appUser }}_err.log || true
  echo "[!] Checking SSH server logs for details..."
  journalctl -u ssh -n 20 --no-pager || journalctl -u sshd -n 20 --no-pager || true
  VERIFICATION_FAILED=1
fi

if [ $VERIFICATION_FAILED -eq 0 ]; then
  echo "[✓] All SSH users verified successfully"
else
  echo "[!] Some SSH verifications failed, but continuing..."
fi

echo "[✓] Provisioning bootstrap complete"
echo ""

# Get server's IP address for summary
SERVER_IP_SUMMARY=$(ip route get 1 2>/dev/null | awk '{print $7;exit}' || hostname -I 2>/dev/null | awk '{print $1}' || echo "Unable to detect")

echo "================================================"
echo "  BrokeForge Provision Summary"
echo "================================================"
echo "Server IP:   ${SERVER_IP_SUMMARY}"
echo "Root user:   {{ $sshUser }}"
echo "App user:    {{ $appUser }}"
echo "SSH Port:    {{ $sshPort ?? 22 }}"
echo "Callback:    Sending completion notification..."
echo "================================================"
echo ""

notify_callback "$CALLBACK_COMPLETED_URL" "completed"
