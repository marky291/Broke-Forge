#!/usr/bin/env bash
set -euo pipefail

# Ensure script is running as root
if [ "$EUID" -ne 0 ]; then
  echo "[!] This script must be run as root user"
  echo "[!] Please run: 'sudo su' first"
  exit 1
fi

CALLBACK_STARTED_URL='{!! $callbackUrls['started'] ?? '' !!}'
CALLBACK_COMPLETED_URL='{!! $callbackUrls['completed'] ?? '' !!}'

notify_callback() {
  local url="$1"
  local callback_type="$2"

  if [ -z "${url}" ]; then
    echo "[!] WARNING: No callback URL provided for ${callback_type}"
    return
  fi

  echo "[→] Sending ${callback_type} callback to BrokeForge..."

  if command -v curl >/dev/null 2>&1; then
    # Use -L to follow redirects and preserve POST method
    if curl -L -X POST "$url" >/dev/null 2>&1; then
      echo "[✓] ${callback_type} callback sent successfully"
    else
      echo "[!] WARNING: ${callback_type} callback failed (curl exit code: $?)"
    fi
  elif command -v wget >/dev/null 2>&1; then
    if wget --method=POST -qO- "$url" >/dev/null 2>&1; then
      echo "[✓] ${callback_type} callback sent successfully"
    else
      echo "[!] WARNING: ${callback_type} callback failed (wget exit code: $?)"
    fi
  else
    echo "[!] WARNING: Neither curl nor wget available - cannot send callback"
  fi
}

notify_callback "$CALLBACK_STARTED_URL" "started"

# Generated by {{ $appName }} for server setup

ROOT_PASSWORD='{{ $rootPassword }}'

echo "[+] Starting provisioning for users: {{ $sshUser }} (root) and {{ $appUser }} (app)"

# Setup SSH for root user ({{ $sshUser }}) with server-specific keys
if [ "{{ $sshUser }}" = "root" ]; then
  # Ensure root SSH directory exists
  if [ ! -d /root/.ssh ]; then
    mkdir -p /root/.ssh
    chmod 700 /root/.ssh
  fi

  # Deploy root private key (for outgoing connections from BrokeForge to this server)
  cat > /root/.ssh/id_rsa <<'ROOT_PRIVATE_KEY_EOF'
{{ $rootPrivateKeyContent }}
ROOT_PRIVATE_KEY_EOF
  chmod 600 /root/.ssh/id_rsa

  # Deploy root public key
  cat > /root/.ssh/id_rsa.pub <<'ROOT_PUBLIC_KEY_EOF'
{{ $rootPublicKeyContent }}
ROOT_PUBLIC_KEY_EOF
  chmod 644 /root/.ssh/id_rsa.pub

  # Add public key to authorized_keys for incoming BrokeForge connections
  if [ ! -f /root/.ssh/authorized_keys ]; then
    touch /root/.ssh/authorized_keys
    chmod 600 /root/.ssh/authorized_keys
  fi
  if ! grep -Fq "{{ trim($rootPublicKeyContent) }}" /root/.ssh/authorized_keys; then
    echo "{{ trim($rootPublicKeyContent) }}" >> /root/.ssh/authorized_keys
  fi

  # Ensure strict ownership
  chown root:root /root
  chown -R root:root /root/.ssh

  echo "[+] Root user SSH keys configured (server-specific)"
else
  # Setup SSH for non-root ssh user if different
  if ! id -u "{{ $sshUser }}" >/dev/null 2>&1; then
    useradd -m -s /bin/bash "{{ $sshUser }}" || adduser --disabled-password --gecos "" "{{ $sshUser }}"
  fi

  mkdir -p "/home/{{ $sshUser }}/.ssh"

  # Deploy root private key
  cat > "/home/{{ $sshUser }}/.ssh/id_rsa" <<'ROOT_PRIVATE_KEY_EOF'
{{ $rootPrivateKeyContent }}
ROOT_PRIVATE_KEY_EOF
  chmod 600 "/home/{{ $sshUser }}/.ssh/id_rsa"

  # Deploy root public key
  cat > "/home/{{ $sshUser }}/.ssh/id_rsa.pub" <<'ROOT_PUBLIC_KEY_EOF'
{{ $rootPublicKeyContent }}
ROOT_PUBLIC_KEY_EOF
  chmod 644 "/home/{{ $sshUser }}/.ssh/id_rsa.pub"

  # Add to authorized_keys
  if [ ! -f "/home/{{ $sshUser }}/.ssh/authorized_keys" ]; then
    touch "/home/{{ $sshUser }}/.ssh/authorized_keys"
  fi
  if ! grep -Fq "{{ trim($rootPublicKeyContent) }}" "/home/{{ $sshUser }}/.ssh/authorized_keys"; then
    echo "{{ trim($rootPublicKeyContent) }}" >> "/home/{{ $sshUser }}/.ssh/authorized_keys"
  fi

  chown -R "{{ $sshUser }}":"{{ $sshUser }}" "/home/{{ $sshUser }}/.ssh"
  chmod 700 "/home/{{ $sshUser }}/.ssh"
  chmod 600 "/home/{{ $sshUser }}/.ssh/authorized_keys"

  echo "[+] SSH user '{{ $sshUser }}' SSH keys configured (server-specific)"
fi

# Setup SSH for application user ({{ $appUser }}) with server-specific keys
if ! id -u "{{ $appUser }}" >/dev/null 2>&1; then
  useradd -m -s /bin/bash "{{ $appUser }}" || adduser --disabled-password --gecos "" "{{ $appUser }}"
fi

mkdir -p "/home/{{ $appUser }}/.ssh"

# Deploy user private key
cat > "/home/{{ $appUser }}/.ssh/id_rsa" <<'USER_PRIVATE_KEY_EOF'
{{ $userPrivateKeyContent }}
USER_PRIVATE_KEY_EOF
chmod 600 "/home/{{ $appUser }}/.ssh/id_rsa"

# Deploy user public key
cat > "/home/{{ $appUser }}/.ssh/id_rsa.pub" <<'USER_PUBLIC_KEY_EOF'
{{ $userPublicKeyContent }}
USER_PUBLIC_KEY_EOF
chmod 644 "/home/{{ $appUser }}/.ssh/id_rsa.pub"

# Add to authorized_keys
if [ ! -f "/home/{{ $appUser }}/.ssh/authorized_keys" ]; then
  touch "/home/{{ $appUser }}/.ssh/authorized_keys"
fi
if ! grep -Fq "{{ trim($userPublicKeyContent) }}" "/home/{{ $appUser }}/.ssh/authorized_keys"; then
  echo "{{ trim($userPublicKeyContent) }}" >> "/home/{{ $appUser }}/.ssh/authorized_keys"
fi

chown -R "{{ $appUser }}":"{{ $appUser }}" "/home/{{ $appUser }}/.ssh"
chmod 700 "/home/{{ $appUser }}/.ssh"
chmod 600 "/home/{{ $appUser }}/.ssh/authorized_keys"

echo "[+] App user '{{ $appUser }}' SSH keys configured (server-specific)"

# Setup worker user for Git operations
if ! id -u "worker" >/dev/null 2>&1; then
  useradd -m -s /bin/bash worker || adduser --disabled-password --gecos "" worker
fi

mkdir -p /home/worker/.ssh
chmod 700 /home/worker/.ssh

# Install worker private key for outgoing Git SSH connections
cat > /home/worker/.ssh/id_rsa <<'WORKER_PRIVATE_KEY_EOF'
{{ $workerPrivateKeyContent }}
WORKER_PRIVATE_KEY_EOF

chmod 600 /home/worker/.ssh/id_rsa

# Install worker public key for reference
cat > /home/worker/.ssh/id_rsa.pub <<'WORKER_PUBLIC_KEY_EOF'
{{ $workerPublicKeyContent }}
WORKER_PUBLIC_KEY_EOF

chmod 644 /home/worker/.ssh/id_rsa.pub

# Add worker public key to authorized_keys for incoming connections from BrokeForge
if [ ! -f /home/worker/.ssh/authorized_keys ]; then
  touch /home/worker/.ssh/authorized_keys
fi
if ! grep -Fq "{{ trim($workerPublicKeyContent) }}" /home/worker/.ssh/authorized_keys; then
  echo "{{ trim($workerPublicKeyContent) }}" >> /home/worker/.ssh/authorized_keys
fi
chmod 600 /home/worker/.ssh/authorized_keys

# Set proper ownership
chown -R worker:worker /home/worker/.ssh

# Add worker to app user's group for directory access
usermod -a -G {{ $appUser }} worker

# Grant worker sudo permissions for Git operations (rm, mkdir, chown, chmod in app user's directory)
cat > /etc/sudoers.d/90-worker-git << 'WORKER_SUDOERS_EOF'
# Allow worker to manage files in app user's home for Git operations
worker ALL=(ALL) NOPASSWD: /bin/rm -rf /home/{{ $appUser }}/*
worker ALL=(ALL) NOPASSWD: /bin/mkdir -p /home/{{ $appUser }}/*
worker ALL=(ALL) NOPASSWD: /bin/chown -R * /home/{{ $appUser }}/*
worker ALL=(ALL) NOPASSWD: /bin/chmod -R * /home/{{ $appUser }}/*
WORKER_SUDOERS_EOF
chmod 440 /etc/sudoers.d/90-worker-git

# Configure Git for worker user
sudo -u worker git config --global user.name '{{ $appName }} Worker'
sudo -u worker git config --global user.email 'worker@{{ str_replace(' ', '', strtolower($appName)) }}.local'

# Set group write permissions on app user's home directory
chmod 775 /home/{{ $appUser }}

echo "[+] Worker user 'worker' configured for Git operations with deployed SSH keys, group access, and sudo permissions"

# Set passwords for all configured users
echo "root:${ROOT_PASSWORD}" | chpasswd

# Set password for SSH user if different from root
if [ "{{ $sshUser }}" != "root" ]; then
  echo "{{ $sshUser }}:${ROOT_PASSWORD}" | chpasswd || true
fi

# Set password for application user
echo "{{ $appUser }}:${ROOT_PASSWORD}" | chpasswd || true

echo "[+] User passwords configured"

# Basic updates and common tools
if command -v apt-get >/dev/null 2>&1; then
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  apt-get install -y curl ca-certificates sudo

  echo "[+] Base packages installed"

  apt-get install -y openssh-server
  systemctl enable --now ssh 2>/dev/null || systemctl enable --now sshd 2>/dev/null || true

  echo "[+] OpenSSH installed"

  mkdir -p /etc/ssh/sshd_config.d
  ssh-keygen -A
  cat > /etc/ssh/sshd_config.d/49-brokeforge.conf <<'EOF'
# Managed by BrokeForge
Port {{ $sshPort ?? 22 }}
PasswordAuthentication no
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PermitRootLogin prohibit-password
EOF

  # Restart SSH and wait for it to be fully ready
  systemctl restart ssh 2>/dev/null || systemctl restart sshd 2>/dev/null || true
  sleep 3

  echo "[+] SSH configuration updated"

  # Generate SSH host keys if they don't exist
  ssh-keygen -A 2>/dev/null || true

  # Get the server's IP address for known_hosts
  SERVER_IP=$(ip route get 1 | awk '{print $7;exit}' 2>/dev/null || hostname -I | awk '{print $1}')

  # Add localhost entries to known_hosts for all users to prevent SSH prompts
  for user_home in /root /home/{{ $sshUser }} /home/{{ $appUser }} /home/worker; do
    if [ -d "$user_home" ]; then
      mkdir -p "$user_home/.ssh"
      touch "$user_home/.ssh/known_hosts"
      ssh-keyscan -H localhost 2>/dev/null >> "$user_home/.ssh/known_hosts" || true
      ssh-keyscan -H 127.0.0.1 2>/dev/null >> "$user_home/.ssh/known_hosts" || true
      if [ -n "$SERVER_IP" ]; then
        ssh-keyscan -H "$SERVER_IP" 2>/dev/null >> "$user_home/.ssh/known_hosts" || true
      fi
      # Fix permissions
      if [ "$user_home" = "/root" ]; then
        chown root:root "$user_home/.ssh/known_hosts"
      elif [ "$user_home" = "/home/{{ $sshUser }}" ]; then
        chown {{ $sshUser }}:{{ $sshUser }} "$user_home/.ssh/known_hosts"
      elif [ "$user_home" = "/home/{{ $appUser }}" ]; then
        chown {{ $appUser }}:{{ $appUser }} "$user_home/.ssh/known_hosts"
      elif [ "$user_home" = "/home/worker" ]; then
        chown worker:worker "$user_home/.ssh/known_hosts"
      fi
      chmod 644 "$user_home/.ssh/known_hosts"
    fi
  done

  # Add GitHub to known_hosts for worker user (for Git operations)
  if [ -d /home/worker/.ssh ]; then
    ssh-keyscan -H github.com 2>/dev/null >> /home/worker/.ssh/known_hosts || true
    ssh-keyscan -H gitlab.com 2>/dev/null >> /home/worker/.ssh/known_hosts || true
    ssh-keyscan -H bitbucket.org 2>/dev/null >> /home/worker/.ssh/known_hosts || true
    chown worker:worker /home/worker/.ssh/known_hosts
    chmod 644 /home/worker/.ssh/known_hosts
  fi

  echo "[+] SSH known_hosts configured (including Git providers for worker)"

  if command -v ufw >/dev/null 2>&1; then
    ufw allow {{ $sshPort ?? 22 }}/tcp || true
  fi
  if command -v firewall-cmd >/dev/null 2>&1 && systemctl is-active --quiet firewalld; then
    firewall-cmd --permanent --add-port={{ $sshPort ?? 22 }}/tcp || true
    firewall-cmd --reload || true
  fi

  echo "[+] Firewall opened for SSH"
fi

# Wait for SSH to be fully ready before declaring completion
echo "[+] Waiting for SSH to be ready..."
sleep 5

# Verify SSH is actually accepting connections on all configured users
echo "[+] Verifying SSH access for all users..."
VERIFICATION_FAILED=0

# Test root user
if ! sudo -u root ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i /root/.ssh/id_rsa root@localhost 'whoami' >/dev/null 2>&1; then
  echo "[!] WARNING: Root SSH verification failed"
  VERIFICATION_FAILED=1
fi

# Test app user
echo "[→] Testing SSH for user: {{ $appUser }}"
if ! sudo -u {{ $appUser }} ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i /home/{{ $appUser }}/.ssh/id_rsa {{ $appUser }}@localhost 'whoami' 2>&1 | tee /tmp/ssh_test_{{ $appUser }}.log | grep -q "{{ $appUser }}"; then
  echo "[!] WARNING: {{ $appUser }} SSH verification failed"
  echo "[!] Debug output:"
  cat /tmp/ssh_test_{{ $appUser }}.log || true
  VERIFICATION_FAILED=1
else
  echo "[✓] {{ $appUser }} SSH verified"
fi

# Test worker user
if ! sudo -u worker ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i /home/worker/.ssh/id_rsa worker@localhost 'whoami' >/dev/null 2>&1; then
  echo "[!] WARNING: Worker SSH verification failed"
  VERIFICATION_FAILED=1
fi

if [ $VERIFICATION_FAILED -eq 0 ]; then
  echo "[✓] All SSH users verified successfully"
else
  echo "[!] Some SSH verifications failed, but continuing..."
fi

echo "[✓] Provisioning bootstrap complete"
echo ""

# Get server's IP address for summary
SERVER_IP_SUMMARY=$(ip route get 1 2>/dev/null | awk '{print $7;exit}' || hostname -I 2>/dev/null | awk '{print $1}' || echo "Unable to detect")

echo "================================================"
echo "  BrokeForge Provision Summary"
echo "================================================"
echo "Server IP:   ${SERVER_IP_SUMMARY}"
echo "Root user:   {{ $sshUser }}"
echo "App user:    {{ $appUser }}"
echo "Worker user: worker"
echo "SSH Port:    {{ $sshPort ?? 22 }}"
echo "Callback:    Sending completion notification..."
echo "================================================"
echo ""

notify_callback "$CALLBACK_COMPLETED_URL" "completed"
